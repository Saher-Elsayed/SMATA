"""
SMATA Driver Component

The Driver is the core integration component providing a unified interface for
orchestrating multiple testing tools (Monkey, Dynodroid, etc.) within a single
framework. Analogous to the UVM Driver that translates sequence items into
pin-level activity on the DUT interface.

Key responsibilities:
- Unified tool interface via standardized APIs
- Dynamic methodology switching based on coverage feedback
- Test sequence orchestration and coordination
- Tool lifecycle management
"""

import time
import logging
import subprocess
import json
from abc import ABC, abstractmethod
from enum import Enum
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


class ToolType(Enum):
    """Supported testing tool types."""
    MONKEY = "monkey"
    DYNODROID = "dynodroid"
    UNIT_TEST = "unit_test"
    ESPRESSO = "espresso"
    TIME_MACHINE = "time_machine"


@dataclass
class ToolConfig:
    """Configuration for a testing tool."""
    tool_type: ToolType
    enabled: bool = True
    priority: int = 1
    max_events: int = 10000
    timeout_seconds: int = 300
    extra_params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TestEvent:
    """A single test event generated by a tool."""
    timestamp: float
    tool: ToolType
    event_type: str
    target: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    result: Optional[str] = None


class ToolAdapter(ABC):
    """
    Abstract base class for tool adapters.
    Each testing tool must implement this interface to integrate with SMATA.
    Follows the Adapter pattern from UVM's driver architecture.
    """

    @abstractmethod
    def initialize(self, config: ToolConfig) -> bool:
        """Initialize the tool with given configuration."""
        pass

    @abstractmethod
    def execute(self, app_package: str, duration_seconds: int) -> List[TestEvent]:
        """Execute the tool against the target application."""
        pass

    @abstractmethod
    def stop(self) -> None:
        """Gracefully stop the tool."""
        pass

    @abstractmethod
    def get_coverage_delta(self) -> float:
        """Return coverage gained since last check."""
        pass

    @abstractmethod
    def is_running(self) -> bool:
        """Check if the tool is currently running."""
        pass


class MonkeyAdapter(ToolAdapter):
    """
    Adapter for Android Monkey testing tool.
    Wraps the 'adb shell monkey' command with SMATA's standardized interface.
    """

    def __init__(self):
        self._running = False
        self._process = None
        self._events: List[TestEvent] = []
        self._coverage_delta = 0.0

    def initialize(self, config: ToolConfig) -> bool:
        self._config = config
        self._events = []
        logger.info(f"MonkeyAdapter initialized: max_events={config.max_events}")
        return True

    def execute(self, app_package: str, duration_seconds: int) -> List[TestEvent]:
        """Execute Monkey testing via ADB."""
        self._running = True
        self._events = []

        cmd = [
            "adb", "shell", "monkey",
            "-p", app_package,
            "--throttle", str(self._config.extra_params.get("throttle", 100)),
            "-v", "-v",
            "--pct-touch", str(self._config.extra_params.get("pct_touch", 30)),
            "--pct-motion", str(self._config.extra_params.get("pct_motion", 20)),
            "--pct-trackball", str(self._config.extra_params.get("pct_trackball", 10)),
            "--pct-syskeys", str(self._config.extra_params.get("pct_syskeys", 10)),
            "--pct-nav", str(self._config.extra_params.get("pct_nav", 15)),
            "--pct-majornav", str(self._config.extra_params.get("pct_majornav", 10)),
            "--pct-appswitch", str(self._config.extra_params.get("pct_appswitch", 5)),
            "-s", str(self._config.extra_params.get("seed", 42)),
            str(self._config.max_events)
        ]

        logger.info(f"Executing Monkey: {' '.join(cmd)}")

        try:
            self._process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            start_time = time.time()
            while time.time() - start_time < duration_seconds:
                if self._process.poll() is not None:
                    break
                time.sleep(0.1)

            if self._process.poll() is None:
                self._process.terminate()

            stdout, stderr = self._process.communicate(timeout=10)
            self._events = self._parse_monkey_output(stdout)

        except FileNotFoundError:
            logger.warning("ADB not found - running in simulation mode")
            self._events = self._simulate_events(duration_seconds)
        except Exception as e:
            logger.error(f"Monkey execution error: {e}")
        finally:
            self._running = False

        return self._events

    def stop(self) -> None:
        if self._process and self._process.poll() is None:
            self._process.terminate()
        self._running = False

    def get_coverage_delta(self) -> float:
        return self._coverage_delta

    def is_running(self) -> bool:
        return self._running

    def _parse_monkey_output(self, output: str) -> List[TestEvent]:
        """Parse Monkey's verbose output into TestEvent objects."""
        events = []
        for line in output.split("\n"):
            if ":Sending" in line:
                event = TestEvent(
                    timestamp=time.time(),
                    tool=ToolType.MONKEY,
                    event_type=self._extract_event_type(line),
                    target="unknown",
                    parameters={"raw": line.strip()}
                )
                events.append(event)
        return events

    def _extract_event_type(self, line: str) -> str:
        if "Touch" in line:
            return "touch"
        elif "Motion" in line:
            return "motion"
        elif "Trackball" in line:
            return "trackball"
        elif "Nav" in line:
            return "navigation"
        elif "Key" in line:
            return "key"
        return "unknown"

    def _simulate_events(self, duration_seconds: int) -> List[TestEvent]:
        """Generate simulated events when ADB is not available."""
        import random
        events = []
        event_types = ["touch", "motion", "key", "navigation", "trackball"]
        num_events = min(self._config.max_events, duration_seconds * 10)

        for i in range(num_events):
            events.append(TestEvent(
                timestamp=time.time() + i * 0.1,
                tool=ToolType.MONKEY,
                event_type=random.choice(event_types),
                target=f"view_{random.randint(0, 50)}",
                parameters={"x": random.randint(0, 1080), "y": random.randint(0, 1920)}
            ))
        return events


class DynodroidAdapter(ToolAdapter):
    """
    Adapter for Dynodroid event-driven testing.
    Implements the observe-select-execute cycle through SMATA's interface.
    """

    def __init__(self):
        self._running = False
        self._events: List[TestEvent] = []
        self._coverage_delta = 0.0

    def initialize(self, config: ToolConfig) -> bool:
        self._config = config
        self._events = []
        logger.info("DynodroidAdapter initialized")
        return True

    def execute(self, app_package: str, duration_seconds: int) -> List[TestEvent]:
        self._running = True
        self._events = []

        try:
            # Dynodroid integration via its command-line interface
            cmd = [
                "python", "-m", "dynodroid",
                "--package", app_package,
                "--timeout", str(duration_seconds),
                "--strategy", self._config.extra_params.get("strategy", "frequency"),
                "--max-events", str(self._config.max_events)
            ]
            logger.info(f"Executing Dynodroid: {' '.join(cmd)}")

            process = subprocess.Popen(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
            )
            stdout, _ = process.communicate(timeout=duration_seconds + 30)
            self._events = self._parse_dynodroid_output(stdout)

        except FileNotFoundError:
            logger.warning("Dynodroid not found - running in simulation mode")
            self._events = self._simulate_events(duration_seconds)
        except Exception as e:
            logger.error(f"Dynodroid execution error: {e}")
        finally:
            self._running = False

        return self._events

    def stop(self) -> None:
        self._running = False

    def get_coverage_delta(self) -> float:
        return self._coverage_delta

    def is_running(self) -> bool:
        return self._running

    def _parse_dynodroid_output(self, output: str) -> List[TestEvent]:
        events = []
        try:
            data = json.loads(output)
            for item in data.get("events", []):
                events.append(TestEvent(
                    timestamp=item.get("timestamp", time.time()),
                    tool=ToolType.DYNODROID,
                    event_type=item.get("type", "unknown"),
                    target=item.get("target", "unknown"),
                    parameters=item.get("params", {})
                ))
        except (json.JSONDecodeError, AttributeError):
            pass
        return events

    def _simulate_events(self, duration_seconds: int) -> List[TestEvent]:
        import random
        events = []
        event_types = ["ui_click", "ui_long_click", "ui_scroll", "system_event", "text_input"]
        num_events = min(self._config.max_events, duration_seconds * 5)

        for i in range(num_events):
            events.append(TestEvent(
                timestamp=time.time() + i * 0.2,
                tool=ToolType.DYNODROID,
                event_type=random.choice(event_types),
                target=f"widget_{random.randint(0, 30)}",
                parameters={"relevance_score": random.uniform(0.3, 1.0)}
            ))
        return events


class CoveragePlateau:
    """Detects when a tool's coverage gain has plateaued."""

    def __init__(self, window_size: int = 5, threshold: float = 0.5):
        self._window_size = window_size
        self._threshold = threshold
        self._history: List[float] = []

    def update(self, coverage: float) -> bool:
        """Returns True if coverage has plateaued."""
        self._history.append(coverage)
        if len(self._history) < self._window_size:
            return False

        recent = self._history[-self._window_size:]
        gain = recent[-1] - recent[0]
        return gain < self._threshold

    def reset(self):
        self._history = []


class SMATADriver:
    """
    Main SMATA Driver - orchestrates multiple testing tools.

    The Driver provides:
    1. Unified interface for tool execution
    2. Dynamic methodology switching based on coverage feedback
    3. Coordinated test sequence management
    4. Coverage plateau detection and tool rotation

    Analogous to UVM's sequencer + driver combination.
    """

    def __init__(self, tools: List[str] = None):
        self._adapters: Dict[ToolType, ToolAdapter] = {}
        self._active_tool: Optional[ToolType] = None
        self._all_events: List[TestEvent] = []
        self._coverage_history: List[Dict] = []
        self._plateau_detector = CoveragePlateau()
        self._monitors = []

        # Register default adapters
        if tools is None:
            tools = ["monkey", "dynodroid"]

        for tool_name in tools:
            if tool_name == "monkey":
                self.register_adapter(ToolType.MONKEY, MonkeyAdapter())
            elif tool_name == "dynodroid":
                self.register_adapter(ToolType.DYNODROID, DynodroidAdapter())

    def register_adapter(self, tool_type: ToolType, adapter: ToolAdapter) -> None:
        """Register a tool adapter with the Driver."""
        self._adapters[tool_type] = adapter
        logger.info(f"Registered adapter: {tool_type.value}")

    def configure_tools(self, configs: Dict[ToolType, ToolConfig]) -> None:
        """Configure all registered tools."""
        for tool_type, config in configs.items():
            if tool_type in self._adapters:
                self._adapters[tool_type].initialize(config)

    def run(self, app_package: str = "com.example.app",
            duration_minutes: int = 60,
            monitors: List = None,
            switch_interval_seconds: int = 300) -> Dict:
        """
        Execute coordinated testing across all registered tools.

        The Driver implements intelligent tool switching:
        1. Start with the first tool
        2. Monitor coverage gain at regular intervals
        3. When coverage plateaus, switch to the next tool
        4. Continue until duration expires

        Args:
            app_package: Target application package name
            duration_minutes: Total testing duration
            monitors: List of monitor instances to attach
            switch_interval_seconds: Time between tool switches

        Returns:
            Dictionary with execution results and statistics
        """
        if monitors:
            self._monitors = monitors

        total_seconds = duration_minutes * 60
        tool_order = list(self._adapters.keys())
        current_tool_idx = 0
        elapsed = 0
        results = {
            "total_events": 0,
            "events_by_tool": {},
            "switches": 0,
            "coverage_timeline": [],
            "tool_sequence": []
        }

        logger.info(f"Starting SMATA Driver: {duration_minutes}min, "
                     f"tools={[t.value for t in tool_order]}")

        while elapsed < total_seconds and tool_order:
            tool_type = tool_order[current_tool_idx % len(tool_order)]
            adapter = self._adapters[tool_type]

            # Determine slice duration
            slice_duration = min(switch_interval_seconds, total_seconds - elapsed)

            logger.info(f"Running {tool_type.value} for {slice_duration}s "
                         f"(elapsed: {elapsed}/{total_seconds}s)")

            # Initialize tool with default config if not already done
            default_config = ToolConfig(tool_type=tool_type)
            adapter.initialize(default_config)

            # Execute tool
            events = adapter.execute(app_package, slice_duration)
            self._all_events.extend(events)

            # Notify monitors
            for monitor in self._monitors:
                if hasattr(monitor, 'record_events'):
                    monitor.record_events(events)

            # Track results
            tool_name = tool_type.value
            if tool_name not in results["events_by_tool"]:
                results["events_by_tool"][tool_name] = 0
            results["events_by_tool"][tool_name] += len(events)
            results["tool_sequence"].append({
                "tool": tool_name,
                "start_time": elapsed,
                "duration": slice_duration,
                "events": len(events)
            })

            elapsed += slice_duration

            # Check for plateau and switch
            coverage = adapter.get_coverage_delta()
            if self._plateau_detector.update(coverage):
                logger.info(f"Coverage plateau detected for {tool_type.value}, switching...")
                self._plateau_detector.reset()
                current_tool_idx += 1
                results["switches"] += 1
            else:
                # Still gaining coverage, continue with same tool
                # but periodically try other tools anyway
                if elapsed % (switch_interval_seconds * 2) == 0:
                    current_tool_idx += 1

        results["total_events"] = len(self._all_events)
        logger.info(f"Driver completed: {results['total_events']} events, "
                     f"{results['switches']} switches")
        return results

    def get_all_events(self) -> List[TestEvent]:
        """Return all recorded events across all tools."""
        return self._all_events

    def get_coverage_history(self) -> List[Dict]:
        """Return coverage measurements over time."""
        return self._coverage_history

    def reset(self) -> None:
        """Reset the driver state for a new test session."""
        self._all_events = []
        self._coverage_history = []
        self._plateau_detector.reset()
        for adapter in self._adapters.values():
            adapter.stop()
